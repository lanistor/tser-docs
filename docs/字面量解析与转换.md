# 字面量解析

## 数字和Bool类型
> 包含`bool`, `int32`, `int64`, `float`, `double`类型。

1. 整数类型: `int32`, `int64`，默认类型为`int32`（`number`类型解释为`int32`）。
2. 浮点类型: `float`, `double`. 默认类型为`double`。
3. Bool类型: `bool`，使用`int1`类型。

### 类型识别
1. 定义语句若指定了类型，直接使用
    1. 当不可识别类型时，或者类型为Any时，则使用默认类型: `int32`或`double`
2. 返回时若函数指定了类型，直接使用
    1. 当不可识别类型时，或者类型为Any时，则使用默认类型: `int32`或`double`
3. 二元运算若若与之计算的值指定了类型，则比较二者，自动向高类型转换

### 类型转换
类型可隐式向上转换或向下转换。
1. 赋值时，强制转换
2. 返回时，强制转换
3. 二元运算时，自动向高类型转换，顺序为: `int1` -> `int32` -> `int64` -> `float` -> `double`

### 常量折叠规则
1. LLVM 常量生成IR时，会自动进行折叠，比如`11+22`会自动转为`33`
2. 常量的类型转换，会自动进行折叠，比如`var a: float = 1.0; var b: float = a+ 2.0;`, 其中`2.0`默认为`double`类型，转换为`float`类型的过程会被折叠，从而表现为: 直接认为`2.0`是float类型

### 常量类型确认规则
1. 常量全部使用默认类型
2. 进行二元计算时（无论是否存在变量），低类型转换为高类型后再计算
比如:
```c++
  float f = 4.0;
  int   g = f + 3.0;
```
规则为: 先将f转换为`double`，再与`3.0`计算，因为`3.0`默认为`double`（学习C++）

### 类型赋值转换
类型赋值时，可强制转换，而且不限定类型，比如`double`可转换为`bool`。

### 类型转换IR设计
类型转换时，首先要计算出目标类型
1. 如果是赋值，直接使用赋值类型为目标类型
2. 如果是隐式转换，使用高类型作为目标类型更高

计算出类型后，判断当前类型与目标类型:

1. 如果是同类转换，比如`int32`和`int64`视为同类，`float`和`double`是为同类
    1. 如果低于目标类型，则使用`zext`扩展至目标类型（高位扩展）
    2. 如果高于目标类型，则使用`trunc`截取至目标类型（高位截取）

2. 如果是跨类型转换，则使用类型转换操作符
    1. `float`、`double` -> `int32`、`int64`: 使用`fptosi to`转换
    2. `int32`、`int64` -> `float`、`double`: 使用`sitofp to`转换
    3. `float`、`double` -> `bool`: 使用`fcmp une`与`0.0`比较返回`bool`类型
    4. `int32`、`int64`  -> `bool`: 使用`icmp ne`与`0`比较返回`bool`类型
    5. `bool` -> `float`、`double`: 使用`uitofp to`转换
    6. `bool` -> `int32`、`int64` : -> : 使用`zext`扩展至目标类型
